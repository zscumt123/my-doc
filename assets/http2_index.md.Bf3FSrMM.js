import{_ as a,c as e,o as l,ae as o}from"./chunks/framework.C0-bF2Gd.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"http2/index.md","filePath":"http2/index.md","lastUpdated":1749550274000}'),i={name:"http2/index.md"};function s(p,t,c,r,h,d){return l(),e("div",null,t[0]||(t[0]=[o('<h2 id="http1存在的问题" tabindex="-1">http1存在的问题 <a class="header-anchor" href="#http1存在的问题" aria-label="Permalink to &quot;http1存在的问题&quot;">​</a></h2><h3 id="_1-队头阻塞" tabindex="-1">1. 队头阻塞 <a class="header-anchor" href="#_1-队头阻塞" aria-label="Permalink to &quot;1. 队头阻塞&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">无法同时发送请求</p><p><code>在单个域名下，HTTP/1.0 并未提供机制来同时请求 资源。如果仅仅使用一个连接，它需要发起请求、等待响应，之后才能发起下一个请求。</code></p></div><div class="tip custom-block"><p class="custom-block-title">管道化的问题</p><ol><li><p>HTTP/1.1 有个特性叫<strong>管道化</strong>，允许一次发送一组请求，但是只能按照发送顺序依次接 收响应。</p></li><li><p>管道化备受互操作性和部署的各种问题的困扰，基本没有实用价值。 在请求应答过程中，如果出现任何状况，剩下所有的工作都会被阻塞在那次请求应答之 后。这就是<strong>队头阻塞</strong>，它会阻碍网络传输和 Web 页面渲染，直至失去响应。</p></li><li><p>为了防止这种问题，现代浏览器会针对单个域名开启 6 个连接，通过各个连接分别发送请求。它实 现了某种程度上的并行，但是每个连接仍会受到“队头阻塞”的影响</p></li></ol></div><h3 id="_2-低效的tcp利用" tabindex="-1">2. 低效的TCP利用 <a class="header-anchor" href="#_2-低效的tcp利用" aria-label="Permalink to &quot;2. 低效的TCP利用&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TCP慢启动</p><p>TCP慢启动无法充分利用网络带宽</p></div><h3 id="_3-臃肿的消息首部" tabindex="-1">3. 臃肿的消息首部 <a class="header-anchor" href="#_3-臃肿的消息首部" aria-label="Permalink to &quot;3. 臃肿的消息首部&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">无法压缩头部信息</p><p>h1只能压缩请求内容，无法压缩消息首部，消息首部加上cookie， 超过千个字节</p></div><h3 id="_4-受限的优先级设置" tabindex="-1">4. 受限的优先级设置 <a class="header-anchor" href="#_4-受限的优先级设置" aria-label="Permalink to &quot;4. 受限的优先级设置&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">无法设置请求优先级</p><p>无法设置请求的优先级，增加排队效应，不灵活</p></div><h2 id="http2的前身-spdy" tabindex="-1">http2的前身 SPDY <a class="header-anchor" href="#http2的前身-spdy" aria-label="Permalink to &quot;http2的前身 SPDY&quot;">​</a></h2><blockquote><p>2009年，google工程师提出了一种http的替代方案 SPDY。 SPDY为 HTTP/2 奠定了基础，并证明了其中一些关键特性的合理性，如多路复用、帧和首部压 缩等。它很快被整合进了 Chrome 和 Firefox，并最终几乎被所有主流浏览器所采有。 而且几乎在同一时间，服务器和网络代理也对 SPDY 提供了必要的支持。</p></blockquote><h2 id="http2协议" tabindex="-1">http2协议 <a class="header-anchor" href="#http2协议" aria-label="Permalink to &quot;http2协议&quot;">​</a></h2><blockquote><p>2012 年初，HTTP 工作组启动了开发下一个HTTP 版本的工作。 HTTP/2.0 被寄予了如下期望：</p></blockquote><ul><li>相比于使用 TCP 的 HTTP/1.1，最终用户可感知的多数延迟都有能够量化的显 著改善；</li><li>解决 HTTP 中的队头阻塞问题；</li><li>并行的实现机制不依赖与服务器建立多个连接，从而提升 TCP 连接的利用率， 特别是在拥塞控制方面；</li><li>保留 HTTP/1.1 的语义，可以利用已有的文档资源（如上所述），包括（但不限于） HTTP 方法、状态码、URI 和首部字段；</li><li>明确定义 HTTP/2.0 和 HTTP/1.x 交互的方法，特别是通过中介时的方法（双向）；</li><li>明确指出它们可以被合理使用的新的扩展点和策略。</li></ul><p>工作组发出了征求建议书的通知，并最终决定使用 SPDY 作为 HTTP/2.0 的起点。最终， RFC7540 在2015年5月14日发布了，HTTP/2 成为正式协议</p>',16)]))}const P=a(i,[["render",s]]);export{T as __pageData,P as default};
